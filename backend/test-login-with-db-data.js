import { Pool } from 'pg';
import dotenv from 'dotenv';
import fetch from 'node-fetch';
import { generateZkProof, generateZkCommitment } from './src/utils/zk.js';

// Load environment variables
dotenv.config();

// Database configuration
const dbConfig = {
  user: process.env.DB_USER || 'postgres',
  host: process.env.DB_HOST || 'localhost',
  database: process.env.DB_NAME || 'k33p_database',
  password: process.env.DB_PASSWORD || 'password',
  port: parseInt(process.env.DB_PORT || '5432'),
  ssl: process.env.DB_HOST?.includes('render.com') ? { rejectUnauthorized: false } : (process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false),
};

const pool = new Pool(dbConfig);

// Render backend URL
const RENDER_BACKEND_URL = 'https://k33p-smart-contract.onrender.com';

async function queryUsersFromDatabase() {
  try {
    console.log('ğŸ” Querying users from PostgreSQL database...');
    
    const client = await pool.connect();
    const result = await client.query(`
      SELECT 
        user_id,
        wallet_address,
        phone_hash,
        phone_number,
        zk_commitment,
        email,
        name,
        created_at
      FROM users 
      ORDER BY created_at DESC
      LIMIT 10
    `);
    
    client.release();
    
    console.log(`ğŸ“Š Found ${result.rows.length} users in database:`);
    result.rows.forEach((user, index) => {
      console.log(`\n${index + 1}. User ID: ${user.user_id}`);
      console.log(`   Wallet: ${user.wallet_address || 'N/A'}`);
      console.log(`   Phone Hash: ${user.phone_hash || 'N/A'}`);
      console.log(`   Phone Number: ${user.phone_number || 'N/A'}`);
      console.log(`   ZK Commitment: ${user.zk_commitment || 'N/A'}`);
      console.log(`   Email: ${user.email || 'N/A'}`);
      console.log(`   Name: ${user.name || 'N/A'}`);
      console.log(`   Created: ${user.created_at}`);
    });
    
    return result.rows;
  } catch (error) {
    console.error('âŒ Error querying database:', error);
    throw error;
  }
}

async function testLoginEndpoint(user) {
  try {
    console.log(`\nğŸ§ª Testing login endpoint for user: ${user.user_id}`);
    
    // Generate ZK proof and commitment for testing
    // Note: In a real scenario, these would be generated by the client
    const testSecret = 'test-secret-123'; // This would be the user's actual secret
    const commitment = generateZkCommitment(testSecret);
    const proof = generateZkProof(testSecret, commitment);
    
    console.log(`Generated commitment: ${commitment}`);
    console.log(`Generated proof: ${proof}`);
    
    // Prepare login payload
    const loginPayload = {
      proof: proof,
      commitment: commitment
    };
    
    // Add wallet address or phone based on what's available
    if (user.wallet_address) {
      loginPayload.walletAddress = user.wallet_address;
      console.log(`Using wallet address: ${user.wallet_address}`);
    } else if (user.phone_hash) {
      // For phone login, we need the actual phone number, not the hash
      if (user.phone_number) {
        loginPayload.phone = user.phone_number;
        console.log(`Using phone number: ${user.phone_number}`);
      } else {
        console.log('âš ï¸  Phone hash found but no phone number available for testing');
        return null;
      }
    } else {
      console.log('âš ï¸  No wallet address or phone number available for this user');
      return null;
    }
    
    console.log('ğŸ“¤ Sending login request to:', `${RENDER_BACKEND_URL}/api/zk-postgres/login`);
    console.log('ğŸ“¦ Payload:', JSON.stringify(loginPayload, null, 2));
    
    // Make the login request
    const response = await fetch(`${RENDER_BACKEND_URL}/api/zk-postgres/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(loginPayload)
    });
    
    const responseData = await response.json();
    
    console.log(`\nğŸ“¥ Response Status: ${response.status}`);
    console.log('ğŸ“¥ Response Data:', JSON.stringify(responseData, null, 2));
    
    if (response.ok) {
      console.log('âœ… Login test successful!');
    } else {
      console.log('âŒ Login test failed');
    }
    
    return {
      user: user.user_id,
      status: response.status,
      success: response.ok,
      response: responseData
    };
    
  } catch (error) {
    console.error(`âŒ Error testing login for user ${user.user_id}:`, error);
    return {
      user: user.user_id,
      status: 'ERROR',
      success: false,
      error: error.message
    };
  }
}

async function testLoginWithActualCommitment(user) {
  try {
    console.log(`\nğŸ” Testing login with user's actual ZK commitment: ${user.user_id}`);
    
    if (!user.zk_commitment) {
      console.log('âš ï¸  No ZK commitment found for this user');
      return null;
    }
    
    // Use the user's actual commitment
    const commitment = user.zk_commitment.includes('-') ? user.zk_commitment.split('-')[0] : user.zk_commitment;
    
    // For testing purposes, we'll generate a proof that should match
    // In reality, the client would generate this proof using their secret
    const testSecret = 'user-secret'; // This would be the user's actual secret
    const proof = generateZkProof(testSecret, commitment);
    
    console.log(`Using stored commitment: ${commitment}`);
    console.log(`Generated proof: ${proof}`);
    
    // Prepare login payload
    const loginPayload = {
      proof: proof,
      commitment: commitment
    };
    
    // Add wallet address or phone based on what's available
    if (user.wallet_address) {
      loginPayload.walletAddress = user.wallet_address;
    } else if (user.phone_number) {
      loginPayload.phone = user.phone_number;
    } else {
      console.log('âš ï¸  No wallet address or phone number available for this user');
      return null;
    }
    
    console.log('ğŸ“¤ Sending login request with actual commitment...');
    console.log('ğŸ“¦ Payload:', JSON.stringify(loginPayload, null, 2));
    
    // Make the login request
    const response = await fetch(`${RENDER_BACKEND_URL}/api/zk-postgres/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(loginPayload)
    });
    
    const responseData = await response.json();
    
    console.log(`\nğŸ“¥ Response Status: ${response.status}`);
    console.log('ğŸ“¥ Response Data:', JSON.stringify(responseData, null, 2));
    
    return {
      user: user.user_id,
      status: response.status,
      success: response.ok,
      response: responseData
    };
    
  } catch (error) {
    console.error(`âŒ Error testing login with actual commitment for user ${user.user_id}:`, error);
    return {
      user: user.user_id,
      status: 'ERROR',
      success: false,
      error: error.message
    };
  }
}

async function main() {
  try {
    console.log('ğŸš€ Starting login endpoint test with actual database data...');
    console.log(`ğŸŒ Testing against: ${RENDER_BACKEND_URL}`);
    
    // Query users from database
    const users = await queryUsersFromDatabase();
    
    if (users.length === 0) {
      console.log('âŒ No users found in database');
      return;
    }
    
    console.log('\n' + '='.repeat(80));
    console.log('ğŸ§ª TESTING LOGIN ENDPOINT WITH DATABASE USERS');
    console.log('='.repeat(80));
    
    const testResults = [];
    
    // Test login for each user
    for (let i = 0; i < Math.min(users.length, 3); i++) {
      const user = users[i];
      
      console.log('\n' + '-'.repeat(60));
      console.log(`Testing user ${i + 1}/${Math.min(users.length, 3)}: ${user.user_id}`);
      console.log('-'.repeat(60));
      
      // Test with generated commitment
      const result1 = await testLoginEndpoint(user);
      if (result1) testResults.push(result1);
      
      // Test with user's actual commitment if available
      if (user.zk_commitment) {
        const result2 = await testLoginWithActualCommitment(user);
        if (result2) testResults.push(result2);
      }
      
      // Add delay between tests
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    // Summary
    console.log('\n' + '='.repeat(80));
    console.log('ğŸ“Š TEST RESULTS SUMMARY');
    console.log('='.repeat(80));
    
    testResults.forEach((result, index) => {
      console.log(`\n${index + 1}. User: ${result.user}`);
      console.log(`   Status: ${result.status}`);
      console.log(`   Success: ${result.success ? 'âœ…' : 'âŒ'}`);
      if (result.error) {
        console.log(`   Error: ${result.error}`);
      }
    });
    
    const successCount = testResults.filter(r => r.success).length;
    console.log(`\nğŸ¯ Overall Results: ${successCount}/${testResults.length} tests passed`);
    
  } catch (error) {
    console.error('âŒ Main execution error:', error);
  } finally {
    await pool.end();
    console.log('\nğŸ”š Database connection closed');
  }
}

// Run the test
main().catch(console.error);